use crate::codec::{byte_decode_1, byte_decode_12};
use crate::field::decompress_1;
use crate::ntt::NTT;
use crate::params::{DU, DV, N, RANK};
use crate::ring::Poly;
use crate::sampler;

#[allow(unused)]
#[derive(Clone, Debug)]
pub struct EncryptionKey {
    key: [u8; 384 * RANK + 32],
}

// pub type KeyState = (EncryptionKey, KeyGenState);

#[derive(Clone, Debug, Default)]
pub struct KeyGenState {
    pub(crate) d: [u8; 32],
    pub(crate) rho: [u8; 32],
    pub(crate) sigma: [u8; 32],
    pub(crate) ah: [[NTT; RANK]; RANK],
}

#[allow(unused)]
impl EncryptionKey {
    // pub fn new(key: [u8; 384 * RANK + 32], seed: [u8; 32], rho: [u8; 32], sigma: [u8; 32], ah: [[NTT; RANK]; RANK]) -> Self {
    pub fn new(key: [u8; 384 * RANK + 32]) -> Self {
        Self { key }
    }

    pub fn key_bytes(&self) -> (&[u8]) {
        &self.key
    }

    pub fn key_and_rho(&self) -> Result<(&[u8; 384 * RANK], &[u8; 32]), bool> {
        let (key_part, rho_part) = self.key.split_at(384 * RANK);
        let key: &[u8; 384 * RANK] = key_part.try_into().map_err(|_| false)?;
        let rho: &[u8; 32] = rho_part.try_into().map_err(|_| false)?;
        Ok((key, rho))
    }
}

#[allow(unused)]
impl EncryptionKey {
    pub fn encrypt(&self, m: [u8; 32], r: [u8; 32]) -> [u8; 32 * (DU * RANK as u8 + DV) as usize] {
        let (kb, rho) = self.key_and_rho().expect("have key and seed");

        let th: [NTT; 3] = {
            let mut th_bytes = [[0u16; N]; RANK];
            for i in 0..RANK {
                byte_decode_12(&kb[i * 384..(i + 1) * 384], &mut th_bytes[i]);
            }
            th_bytes.map(|b| b.into())
        };

        let ah = {
            let mut ah: [[NTT; RANK]; RANK] = [[NTT::default(); RANK]; RANK];
            NTT::sample_ntt_matrix(rho, &mut ah);
            ah
        };

        let (y, n): ([Poly; RANK], u8) = {
            let mut n = 0;
            let mut y = [Poly::default(); RANK];
            sampler::sample_secret_eta1(r, &mut n, &mut y);
            (y, n)
        };

        let (e1, mut n): ([Poly; RANK], u8) = {
            assert_eq!(n, RANK as u8);
            let mut n = n;
            let mut e1 = [Poly::default(); RANK];
            for i in 0..RANK {
                sampler::sample_secret_eta2(r, n, &mut e1[i]);
                n += 1;
            }
            (e1, n)
        };

        assert_eq!(n, 2*RANK as u8);
        let mut e2 = Poly::default();
        sampler::sample_secret_eta2(r, n, &mut e2);

        let yh = y.map(|y| NTT::from_poly(&y));
        let prod_ah_yh = {
            let mut prod_ah_yh = [NTT::default(); RANK];
            for i in 0..RANK {
                for j in 0..RANK {
                    prod_ah_yh[i] = prod_ah_yh[i].add(&ah[j][i].mul(&yh[j]));
                }
            }
            prod_ah_yh
        };
        let prod = prod_ah_yh.map(|p| p.inv());
        let u: [Poly; 3] = std::array::from_fn(|i| prod[i].add(&e1[i]));

        let mu: Poly = {
            let mut md = [0u16; N];
            byte_decode_1(m.as_slice(), &mut md);
            Poly::from(&md.map(|b| decompress_1(b)))
        };

        let prod_th_yh = {
            let mut prod_th_yh = NTT::default();
            for i in 0..RANK {
                prod_th_yh = prod_th_yh.add(&th[i].mul(&yh[i]));
            }
            prod_th_yh.inv()
        };

        let c1: [u8; 32*RANK*DU as usize] = {
            let mut c1: [u8; 32*RANK*DU as usize] = [0u8; 32*RANK*DU as usize];
            for i in 0..RANK {
                c1[i*32*DU as usize..][..32*DU as usize]
                    .copy_from_slice(&u[i].compress::<DU>().byte_encode_du());
            }
            c1
        };

        let c2 = (prod_th_yh.add(&e2).add(&mu))
            .compress::<DV>()
            .byte_encode_dv();
        let mut ct = [0u8; 32 * (DU*RANK as u8 + DV) as usize];
        ct[0..32*RANK*DU as usize].copy_from_slice(&c1);
        ct[32*RANK*DU as usize..].copy_from_slice(&c2);

        ct
    }
}
#[cfg(test)]
mod pke_encrypt_tests {
    use crate::encrypt::EncryptionKey;
    use crate::params::{DU, DV, RANK};
    use crate::pke;
    use crate::prf;

    #[test]
    fn test_encrypt_00() {
        let d = hex::decode("684a29e4e5480a5f2533e1526b5fac8cdf5927f3d85087c71f928c59690eb565")
            .unwrap();
        let d: [u8; 32] = d.try_into().unwrap();
        let exp_pk: [u8; 1184] = hex::decode("4f27944614c35d121bf2390402bc93797055936a2d49699cdeec2f29413403aa1024d802d97c54aa316707c26a0b432821f63cd89a87f769597cec8356c2c399d3a34115cca89b9df6a55e4556a3b2150b51907ce67b860f697a65b199b370691fdcb31cf7937d1524bef41a0732cfdf464175c95d9092176ce52814d3a9231114cc31718755ccd3a7b3fe69b4290175dc440cd38c69faecb190ca684fb1001b5308fb4c1ff6a55b4be8814d602ec59c2deed654c93a45d55a3e020800e98aa786c76fcf33cea3a7bdbffa5037a171044b1b74d6094d1a3b606009b4fb0f060b6dd1d29ae67ab90c90c25db895c9515fe0a17bdd69c6773518a532ae8ac731e32155500204dae2c9284cc16f61b5a9e48334859357506e2c391d1bd38865ea489e492d8b847a6a50ba074320fa32074d89894324a705dba4e1847a5059645c77063809cbf3cb0555b6be4069c77b10a6c6f67ae1e7c09d603e87a34acd3b814d7b4798dc05acba65220289772abdbd89403e698f3556511e152bc0f77509dc36803b57d08129951ac44ecc49f43b7cfe8436baa8b5376999f6442293352e76ac592b95804217817ad5a75a76caa72172df9c69da4c170e937a69d93f12c7b533d4bce41b34d0cc8a1c969947db2c21a960d975ac029280ecbb527654a42385576286915d4b8f3fd163f0cb280736bee89786fa277c8487b0820416985855a95a10647059cf34c08915985c32321b5b8b45a468cd4253c662847eea36fb238098f059630cac83aa70cc9596cc1a0406e993b737c236e78cfbea1191d60fc6428fe7090997f1ab41c13e0c57a256a813bc559ad1e6ad10dc3cf43a64dae2955f03b46a09ac6ee30326d95d6ca8b80e61aab77579c017a1906279ac09766bd8a1b40b24d8bc4deefaab47f9c14a8441eb413dbd718e5122ae7beb94f526a31bda25d893a544670d994530d3c6ca29879085870f6d54192b1a7fd63193c7423be4867d2c134683ba25f9240e0fa2a96b47c5ac05b541c2980f51557989b3eba42dad002412f462acf75b141c5fc320bdafd3c11be291eafc04d6b5a1d4117c7703c313eaa30477253e938764364b25d859aca263962c5d6d898ada856b70e151dfa41289213acda6cdb5241bc7067bee5cb467c34d2b0a6ded6aa746290ee2e40b7be1294c583aaf415dd03213a3cb2e41f10731823e749acbc53767c12b93d8f32257a54c6a71b2041a167d685f0bf789b94b277f1b60af22c09b639ac72ca25b1c69b855bed6377126999c5708789091cedce768b253ccae981715c8922dc9562ea8a0ba102b02585281b15c7e44339cf630529c1b076106ee2b5c7be0181ce43d397a398c8547da703e2ab47bc15284f4c6a50dcb904ec9c1f60a1aeef38435997871e8501d4832bbb2a3354c70d9579f237427135329cda32573089687d9a9130375bf66ac321113a25a08aa75cb667635455a93eae7a0a6703a2dc0a85637681ecb097f1b16b2b331210b6288b13f5752bb6c731adab30ca051a817099095022892d923f571b8d879c8ddf0ab03145a32298dc6b644b25640d808006e3113accc6a0c1ccb05ec273e6b6559e287539c72d754ba9bc48c915acebb656e3cb7713e9bfc0bb6f311485ebaa078b78a737d81d38d368c220eb0e982fb0bd8a7ed97").unwrap().try_into().unwrap();
        let (pk, _, _) = pke::key_gen(d);
        assert_eq!(pk.key, exp_pk);
        let _e = pk.encrypt([0x00; 32].into(), [0x00; 32].into());

        let m: [u8; 32] = hex::decode("492d4cea1c6e07d9535ab2fc21d773bea7ee2c7d66ec80d41191aed269a398d6").unwrap().try_into().unwrap();
        let mut hash_ek = [0u8; 32];
        prf::sha3_256(&pk.key, &mut hash_ek); // H(ek)
        let mut m_h_ek: [u8; 64] = [0u8; 64];
        m_h_ek[0..32].copy_from_slice(&m);
        m_h_ek[32..].copy_from_slice(&hash_ek);
        let mut hash = [0u8; 64];

        prf::sha3_512(&m_h_ek, &mut hash); // G(m||H(ek))
        let r: [u8; 32] = hash[32..].try_into().unwrap();

        let ct = pk.encrypt(m.into(), r);
        let exp_ct: [u8; 32usize*(DU as usize * RANK + DV as usize)] = hex::decode("b4d9dfe6717cff99afe645e90f9e9a497833488b2340c1473ceb6c39b944d7cdb748a3e961bdd632d923769aea3b177cf25a36f86f94e80332b720f0f58a134ad8c6f7b31ad0388697864a3d91f43bdc9fa163fe572aecfbaa28d8ceaaa0e92f17eabaebe9d3e117a1bc3c454c3d66e35f7b76baf327d29fbbe8d35142a1e4360a70d0de8d46977a688b6b488720afeb05f846aaafe9fc66aea186961f63264a8a1ae0d721d49385699354b745f46669f89a20b493a836774115736184732b3d0e4374558622ea186d28e822c98dba24f2fa6d233112a89c73994938c362d830aa95113d0989dc4cfdb8d50f0c872d248dcd60212c6c650ddb1679e9419acb2d2ffb8540f578f55a0d03474e3f76fdbbe15af07e3a5251574f6707b2de3a433c0c8a7b04ba67391d27534ac945dc014e9f655068b5c14bea32efec6e6ba1789b1f5c37dca456e52b66ae3a9323671954774caa1697c87dce1d2425326b7185eb986feb59eae87aa2f902e958c6f3c4cc4af8eccb7290ecc824db1a695c3dd643bc0d7c51b416acc184c00c486bb33759be1fe9750cff4282a111723a16e6adae00ea34ecde4b197e8cc1c370635ed2f1e36afa30e76d3c4450ef839c48c016230cb1cdc3b2cd9e64d2e19b50df9633f65db9088177e385502b8a782955cbd6b2e56185e0b3734aa0281734a61c5359d6c4b938424c55a467712ffb555ab782bacc5fd418910a13f28af859ae406bd7fd90490961c12f64927dec576077d4dcdf933c8f6150d8f4f1316c6e28c1f3a0784587621f3d05b6e7ee6877c56cfc97a93c337616c6a940f8d0455fad51fc1233425433ec89055ba451fe31bc51a41f6a4ee8c7aad6f365cce7c373c53bc674111a74fe2c3c187f6615ce07e7b2fd45a148d95f7649ad52ab94bced68b16fa4df9f9906c498be510d7d9d74d33370e893e0bf2f516ea981f06ebf20988ec059bc58835711ad20d8f1f4e47fea65d7f37a5d813dabe1a2c97e1b316d6825bfcd07b592a4834aa204148accda22ce8758335cb3c73db9a51261508eef5b5a2fae5a6a6ec0721313c6ee85d3c29191158d8a3d73d4a475171639a531dd8822682ea4c2375eddbd6df395066e33a16dd5d2cd81f9557268603f2b831fcfe92af431a7780ad0ff9500129ad7959c4975422a1476dfed8a280a24b1158f9fa44dedd77b9a3b883c53cefd56b9ee8bf3a8a3d4d48fda159fa7eb0abc9f69448a8faf53c15ec5f1bd9c6c9eccbf65ede2db9032b22e0a60461a86f3707a3a829968fa59dc21078891c654e8a8fe4d0efa640ee179429e5c0396178c094fdb18b6a4495a518ab6db016629feb51ed10929c4ef3f3710f3170af26a41e197aa709575c0d1a8180f8e81aa6790663a7b2623518734cc9c1d939b2971d011b1de2ad96eb4e87379abcc43334e4b4a4bf8f76cad70ba00465241ee09b6eaf3b93ae18a31fe50f2a05b8b57b76c43e3aec7310e17f385506f771bb7c67cd97f606a2a9db409b3cc3febf2cb0d762490f9aeeb8c9b7b0586").unwrap().try_into().unwrap();
        assert_eq!(ct, exp_ct);

        let ss: [u8; 32] = hash[0..32].try_into().unwrap();
        let exp_ss: [u8; 32] = hex::decode("a154db38fa0190042b01911ac8ec66a01f704f397e8e134e70cdf4b773a32484").unwrap().try_into().unwrap();
        assert_eq!(ss, exp_ss);
    }

    #[test]
    fn test_encrypt_01() {
        let _pk_: [u8; 384*RANK+32] = hex::decode("F255CE47334283B8622BE7CE76D7354E3C4FE3F6C44F6BB25C9864EE0BAEB5765950D88F438263CE8B5A7A4C0FC4C95F10C477A7521F9BB458B8AA55D2E43BDC86B72F0930EE428B4C5A9C7116310F2AA5CB03AC1603C811959EA9012D69CBCE40B37CD890999CC74FF375C66F048B240363343CB795998856D560F4C712938C79466864D20B0BE95419C9EA6A8E7203A1986D10B606691242CEF630941B116458A41C83B7DC5B06A97C840B116F2CE9CFA87A1C1AA8C4FAC137DE8498E8749B3638404271539B247183A32E7E4413B6400E0F295788084EEA93B4A7653341005672D908C62B64B11B48414B505F3036EE56CC4DA88FEF27B2DA974C9DD38C150090B5B8A29BD7C5975A8A959549044B4DAED52A7FA68335308F40C9B768C5821F78CF068A694978964F597408D09759A19578624C64DC18EAB23082E599EC488DFE016E4BA58977E15B715C612496310219B9B4775CB51C5DF03B934F7473AA58A57C602CF17C5993D30F52D753AC56BACA1A994742BC50435E179A262B3C8EECE1513955C593E7508B945F6E95CC4268CBD45B2504082FB8B23D8906946A74AC2FB676BDBC39DF76B9B8450F49D283C622784565B76B96084DFC099EC2279E5BC13492561B4439E32324B0050C5FE6451974BF0D72750AC58BAC046D218AC397F65532ACC7800246ED1C8094FC807306BF88E2816AD13B06F2898CA87C486A124B618156A090B1058722ABAE389AB5612CA2C2766DDEF98202A6AB1097B392404EA151788528B07544325F851B4DEAA2495138F929BBB4026042B0A8CD3CB0A7D061927A717D4877E0D9A409D6B125361C99090AFDF922A776ACADA2B6A84522134B089D4B428020C83061A87816C6A59263E636B5B2ECBCA6A64E29600948D5B0B45600B8D473A65B450B766D0251B6915898BC3C1C2C53B9679121F1F06CFB9604DE0051FF4B093939C907AB18C2988646A90481BB99F4153611C138BE34BE163B3ABAC44354A774E9CB54FB29903367C78D275467499D22E83A11CA9B8445BE9DF3CB612069222A8715A495D115B4BC2457AB731AE7EC1BD8EC9722CA980958180AC2BD67898F4A72A675106D66981B2E923C0BA40E3234655D00B25D6462591C9C9C7A53491489D57A77B2510D08B95B9C61C1784BA752F4A73023742ECB985DFB37808B16D6C283CD4A06C5A3AC401855E1DABE63F9668BF7A661946B18230A1A5A7C19DA66ED08151E77A624F579D4E44ABE023A1CD33459FCC3F1A6589426634D062D0A75A387A0B7B8D802A66B2106E01264500915B97307C85ECF331BCAC35E4AA243C837876D858AFA8B510C342708B38093B2CD35D1BA68DA0544794D172C6CA8850A7F847B56998D8E0B0A17144FB6F443E3679767CA91B80A6CAA8BB0E22BBAC01C0EAE1604B8A243911672B3748C7F18C531E3783D522039130057198D6F0989E99641AB718DA123710BDB67B3B75EC66BA9CF459FE06C7C4F7959DD7281FF155940B09FB14AA55CD40B963CA3312C05B36A5207C989428C16E5D288ADB18A66F74617CA39DB8AA612D706DFEC884C457AECD1AAB598195B4AC971529FB7A883492235E62112064A0F6FF5BF4F1619A0D03B96B5112009966B2DF7C2F300B6F295DF7FA2C453E1949DF6405309DF7575C7656C245EDCA9F6")
            .unwrap().try_into().unwrap();
        let m: [u8; 32] = hex::decode("5BD922AF345AB90F297D0A82EA39527A648E4977AB56242E2AC0ED9A2CC66F10").unwrap().try_into().unwrap();
        let pk= EncryptionKey::new(_pk_);

        let mut hash_ek = [0u8; 32];
        prf::sha3_256(&_pk_, &mut hash_ek); // H(ek)
        let mut m_h_ek: [u8; 64] = [0u8; 64];
        m_h_ek[0..32].copy_from_slice(&m);
        m_h_ek[32..].copy_from_slice(&hash_ek);
        let mut hash = [0u8; 64];

        prf::sha3_512(&m_h_ek, &mut hash); // G(m||H(ek))
        let r: [u8; 32] = hash[32..].try_into().unwrap();

        let ct = pk.encrypt(m.into(), r);
        let exp_ct: [u8; 32usize*(DU as usize * RANK + DV as usize)] = hex::decode("4EE24D9E0858B36DC755A9389F4FDBF438DB8FBFDDD2E2A41FBFE7313693E87B2BD86A2A5C95286840A2E477F4AAC12F28319D892C30FE9A120A09713369A17D5EC459C7E5DCD402F9049BF6FF0F7D07A7F18D4C1E3E0429BF6D501EEDD33E114423A5C4692738096101EC79233F20C58A6EA7E855C4E608DA7C9EE086EEAFE296F3214BD0B9264AE18069342AB493BBEE267401FEDAE19D5F9224A11D911505CB3200C65F17C91F88FBE25621402C939F071C48D6BC6ACD207C8C215E2FF23AB5FAD94F2CE61003C99DE15195B36ADE08864043CAEA49D4EA1D550978C49455B06AFB4BA4F0C178D30F953D47F0258370FE8E686802085FDCB25598DE439CEEA186F848AE2E4ACF526E03755D0A89A941A08C5610C96DFB3F47C693E7E899E1DD38DFD9126F3D05751234ABB82D2BBA4D347823B97293AE2B58FD3C71D2216797DA1CA453D600C5A9A6B36CA23B9450894A894A42C40B38871F1E9E84B40A04112CC9A4B6E7B8DE59CAE5D8389687DBB1EA078F3CC93DC5D0788A671530D9FFDE5F2CB6A558AB38E038D59ED1EF1FEE381AFB6DE0A77E1333FC5B0FE3EA2DCDB84FB33795449AC6DC322F4E5E09B2A462D3750BA426C04271903CFE9A3F02221B69E474F24B7DB608492C01AAC3F2FA472A2469B6A8A949A67C567D139D6F40B00DF1AAC1E6456FFAA646E0DEBD79907905F28076F78ECB3DD1A6493A40F3D1F8D89C71AD15D22162264D0AA73581AF7A77EEA43B856370182348034810E60A902604B724E09EA4638AAB039982A64EF02C9C21259A381BFD3BF298EFE4285CB538F79BE01CCEE1A4A903A80132942AC6BCD4425BD197EF014E7DBEFFDFDD5AAD00DA2A5E8DE4FFF1E8E97F23F3F4BE38970AC09CB99D252CF2736059CFDE177EA6B36EA329B9DC541C3DCE61FAC504908857184C936C1A1C4AC0C8DDE9A66B4F3AAADEAB2DBEB2F2E6422A49A6B9C223DF25A34720717253DA6DCFC0A825553A1D2884E01A97060886FC30A1AD50E52C46F6F9B87274AD6369FCE4FDF3FF6A5D62D4AC82CBCECE902E4DE4214B71A2CA547C536380DCA26F63F2BE71B01EAC68F42AD1399D390404AA5539A5995254836FE6CF59C490B13CAC01C69E50CDC0EBA1C2F9978F4223AA38DA33639ABE933B40F6E2751515EFAC9896465041D3922A4B043897083F7CC6DAF1FD87B970BB6D1D5E48B599FE6CD2AFBA5FCE17E4BD4B0217E879FAE34FC227EC132D6F7141A48D14DED57729164A1D2B0BEF89A16244EE114AB4E108648B7E80A7DD502B0DBD0C38AF1D85AF6966BFB8E54237000A3F18C48EFEB93ED62B41A9B341361D0D7AE75D63A3A34DCEE329996AB0630553F38BC0DA148419162A31D386745C818E2691411A7927E49822AAE9EA918BF49D6809290B57C1BA5EC212F135AC0B8EE945C0510CFED4DB5A84B617BA1525E996486728E1DB87B6E99CC9A7EC4399B063D3943FE4EB1933E90365A4916CA8D67D064DF7D5B8DFC51E337247CAC3CFFAEDC5523276CDCB82B130D8E1C3FB6D7D69").unwrap().try_into().unwrap();
        assert_eq!(ct, exp_ct);

        let ss: [u8; 32] = hash[0..32].try_into().unwrap();
        let exp_ss: [u8; 32] = hex::decode("B2425299020BCF563B8EBE0512F0479941335A75A32B8D10BFF60E5548B64672").unwrap().try_into().unwrap();
        assert_eq!(ss, exp_ss);
    }

    #[test]
    fn test_encrypt_02() {
        let _pk_: [u8; 384*RANK+32] = hex::decode("3543CED7C2159F7734C9C5234B0050177B8E5D4022F40B3D2BBC8DE8B9A2422C711FE97C17BB7078321EC81C8204F682FABC3614120853D29AE9C1A3811B4E422836BC021A4F6ACC9F06BC3867B55D98589AF51A9F64103ED244A12B82BEFABED58AA11511AFE711AF87F06DE3463E5AAC6EEDEAAEB012CF77128461CB5B38840381A08E0A8119A0EA9302D48488053DD7550F7D3CB2507A6F69E186BED53D72276C517B3A4AE90E74C24CFB09C79E72BC188389F657B9F9C6BB8E5A7AE3832AF4453CDC4337CA9B029F91BD6F4735E5BA6FAAE805F11779DDA19BB1E81BC9F7207F9C4F58A795600C2A8ED03876D3729622605B2C13AE72065D077631C7AEAB226B7111C926A7C0B35AA9CE208F3020111CA6266C91A138A9CE7911BD641621E9CB3CB0941E343588068A4992B0A6954BA5D498545CF62C5A201558CCA2FE9514EC92043D2B013E254FC5F3A18880120901B63273BF99810DA49A56780612DB98894396C449F0CCFDA915BAE829974A157D09729AD90918FABE51B72D49134741B0C97429A558359E0642388A503D5E309E2371B2663327B1A7498376AA4F1AB0D320B4D2852EE9EC28825C9C9F4287A190BCCB170CCA897D08C90B2C186AB7F23309F274D7959D2C1003FA8333A1491C5C645F34C094FEFA104E554CDFF63EF955ADD55A9CE5753A150C6D9BFA382541B984103DC78B662D114BEA830E95134158CBB854310CAE406BBCE4CE82B7257C330E8B113790954BF19CBA1FC25828EC06E17C73E135CDF5748490681F7BE052EAB149912528B2004B2B02725852C28E8B566291AA02C1A410717987B22B3D29B5DA9363B63B33F4108C6783186236288A31BFF07482C189AA4C4C5F4B6024C388CBE049A02CC0A6CB52886A25B9B9423AA4716D0F65308D61CA33649884CA4910A00D9F8B6D56DB719E470291DA6802F57D452531FDE36ADAB00450C3735CB8C0484BA8F6E8A939819FBB9AC548905E13458A278579A6E5160950846BA1A9E4D62EBDEB8C8F9B1CA26C20F76BA90C5679B2BA4D8EE4B963557DB1E8C891729DA1F421FF20C42261654E753C63A39DC7B9094A20AAA3E29DF29327AF314576A8CBDC5AB55B8C4B91DB1DF25304E808B677FB9FA2F82D15A957CD8485DD5A35999B992CE428795897C1BB18DF01C0DE2B0D45620F31D820B41282C4D98D95825AC52B11310A1EEBCC6724D4BDF7A3B69A1C1D63047969A058FBEB926F68696B6761F4F66B3D7A31878006901853C58128C9CA6A911764A244A290F96D00DC38343244803BC647C6152FE9BBD0CB82A4467AA4D25CE175C08009B867F60D9A32138D3864F719A2B798987430C0C7326D3BEB3F895472B2D054030366111CC2DEF60C7800CE3BDA023A062BC2351393AC44DFF30B49E60F907404562159B5077B31E6675D905CC7C1CB4CD64B2AF5AFA50CC387C333AEC7CABA219CB4C8A8952B429A1BCF05D78EC65A908436256F46114A19AF2F1A0EAD0C12AED4171EF653F3D2802749C618D70006D68664EAB3B876B48FC298256577CE34AB5127CEE03433B2CA9B403C0A39B02657180C829684A7A58458487E00143CEFD5AFFEF316F2E716B0B42416975E44A63EC62269966C6C71F9B01C5C839BC3E778ADD880E2126F8776B0264707617CD467E982E2DEF5E1")
            .unwrap().try_into().unwrap();
        let m: [u8; 32] = hex::decode("87B25E0AFC6E9D186DF7DA6C3D9E048E1B16C990866367BD903C779266CFD537").unwrap().try_into().unwrap();
        let pk= EncryptionKey::new(_pk_);

        let mut hash_ek = [0u8; 32];
        prf::sha3_256(&_pk_, &mut hash_ek); // H(ek)
        let mut m_h_ek: [u8; 64] = [0u8; 64];
        m_h_ek[0..32].copy_from_slice(&m);
        m_h_ek[32..].copy_from_slice(&hash_ek);
        let mut hash = [0u8; 64];

        prf::sha3_512(&m_h_ek, &mut hash); // G(m||H(ek))
        let r: [u8; 32] = hash[32..].try_into().unwrap();

        let ct = pk.encrypt(m.into(), r);
        let exp_ct: [u8; 32usize*(DU as usize * RANK + DV as usize)] =
            hex::decode("8DC7D4F120658976B15D3C35E427D16592F751214F771E678A32BDD0AE0A60C59143FA54AA101EA2757134378D5127A3D37AA814B801C6315183FA7692D0939B756D6835F847D64E8141B97F9A8AD5C028C3CC6574B2EB60C48F40FDBF0341CC2C5EAAD543D0B0881C51267E52E855414ED37924F2275E011D18DCBAEF20AD3ADAFD0F60D82083DCC352174D625C8CC1120DC1BA4D36F34206074551ADF8F4624CEB60563C6D4AC015ED814F3B520C68F650EEB02A38AE2191AFBA2D6F39E53F34EF8D6E5FA32214EE7B924BEFE1C0956EA77C00EB7178DE11DB5E8747EBE92466491133D711BD141C99549CD59A58CE30DBF759C9EC8851279514EA6F0CE209FDAF36866018E0117C3AAD232FC79615257BA51D70AE1A3B173D6F03BC3C010B6A292328B9FF67622A72DDD409FCA24F2774D7E506998DB6704C96FFEACF8961A6D0783277E076F687088C08C66CDBC34AE9E5AE13F43C81E17EDE3F2DECB2471730150E7113037F5CD20F049CC15AD918D1127DF7E9E92E794F0E90F6866033136AA5BE7A23056E0010E46C5AA30982B8F905F785FE6BEA752847D64656A34D408FC8E37216EB7CC387E0EDF1A216C015C890B5835940ACE44A3EC7FD7A832CAB354052857A4204488D78F7EA1B421A4A16C030E5B34FFB8E6EB57CB21BAF746CB1BCC6CECC9A80FF694FE9C121D611C210B15F0AE2FFE0CE2856CE469474E374E6D9924718F12F8CCEAFAF090C84B14420AB8A09CE2EF53F76FB7EBA985B812D7B54D0704169BC9EAF5DC6490FA183CA78FB2EA5F9463B6F1C7FFEDC6213AE8B813F861B130A4876F9DA32C77B819733D58B0830F49FA237099AEBF2711C6C3EAFD4846D3CDFFDFCD3D9A2AE56DBBA4D9304AEDE0F53B12451425BAB5CBB76ED79FA13E7749E1537880A951F9D803E3439F0A843C0BA26313E44D458CB68771187DCCC363555FCB18C15DDA69F39F90FF0F8588632371170ED76B398D8E36C5EBBAEE40656C241BFA47DC914B8CFB9B4011F357B667B3E7EE68B66FB006192202A3D5FF44528BF3CE81A98922980C5C81E9AC05A860C5AFC73B9AE95ED5A0DE7E2AACA24BE1FE5B81EFA2D936CE86BF846AD7C30775F7EE7E3728510754E363292CF5E68E64164A58E8C874C868AE51F5E5A9FA7BD8BA9F30585E85DD37F4BC24E87FEADA9D7277B65DD53BE0059C1E01AD40A79D95A0F99B1D7CA2A1CC87D4053692F7422036E6EFFAC4B1E691156EC1C3F5EEDC52E598A2A91CC1FE926BB4D977A8068BC5DEFD378B1C19B8B2C865D2287B9DDFAA16D37B7EFA09F8CEF1968D491702F8F4B85BA9E7EAF90C7CB634FCBA21B46F53CF02C72474F1FF8D1484CF6BDBF640B54FB86E9F2829A96DFDD8DE9C362ABEF65A6A8E619F4F70DB8B9C0B57CB904D5F4760961C911458DCFD6A9470D563DEB107DCE157747941B2A034FAFDA07F3E4237AB439C8E7D188CC360C907038EEFB0D2DB48B50F2D07D0EB5EB8A51247CDE6A0B7DEBAC3C79E0DA2B471431599396885420ABCB0306B2118C").unwrap().try_into().unwrap();
        assert_eq!(ct, exp_ct);

        let ss: [u8; 32] = hash[0..32].try_into().unwrap();
        let exp_ss: [u8; 32] = hex::decode("805D0E35A351258C79BA481973A7F21A8293FF0F11807EF1E4D33F68C8A7D103").unwrap().try_into().unwrap();
        assert_eq!(ss, exp_ss);
    }
}
