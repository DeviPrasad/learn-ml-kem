use crate::codec::byte_encode_12;
use crate::ntt::NTT;
use crate::params::{ETA1, RANK};
use crate::ring::Poly;
use crate::{prf, sampler};

#[allow(unused)]
#[derive(Clone, Debug, PartialEq)]
pub struct EncryptionKey {
    key: [u8; 384 * RANK + 32],
    seed: [u8; 32],
    rho: [u8; 32],
    sigma: [u8; 32],
}

#[allow(unused)]
impl EncryptionKey {
    pub fn new(key: [u8; 384 * RANK + 32], seed: [u8; 32], rho: [u8; 32], sigma: [u8; 32]) -> Self {
        Self {
            key,
            seed,
            rho,
            sigma,
        }
    }
}

#[allow(unused)]
pub struct DecryptionKey {
    key: [u8; 384 * RANK],
}

#[allow(unused)]
impl DecryptionKey {
    pub fn new(key: [u8; 384 * RANK]) -> Self {
        DecryptionKey { key }
    }
}

#[allow(unused)]
fn gen_rho_sigma(sr: [u8; 33], rho: &mut [u8; 32], sigma: &mut [u8; 32]) {
    let mut pr = [0u8; 64];
    prf::sha3_512(&sr, &mut pr);
    rho.copy_from_slice(&pr[0..32]);
    sigma.copy_from_slice(&pr[32..]);
}

#[allow(unused)]
pub fn key_gen(d: [u8; 32]) -> (EncryptionKey, DecryptionKey) {
    let sr = {
        let mut sr = [0u8; 33];
        sr[0..32].copy_from_slice(&d);
        sr[32] = RANK as u8;
        sr
    };

    let (rho, sigma) = {
        let mut rho = [0u8; 32];
        let mut sigma = [0u8; 32];
        gen_rho_sigma(sr, &mut rho, &mut sigma);
        (rho, sigma)
    };

    let ah: [[NTT; RANK]; RANK] = {
        let mut rho_j_i = [0u8; 34];
        rho_j_i[0..32].copy_from_slice(&rho);
        let mut ah: [[NTT; RANK]; RANK] = [[NTT::default(); RANK]; RANK];
        for i in 0..RANK {
            rho_j_i[33] = i as u8;
            for j in 0..RANK {
                rho_j_i[32] = j as u8;
                NTT::sample_ntt(&rho_j_i, &mut ah[i][j]);
            }
        }
        ah
    };
    let (s, n) = {
        let mut n = 0;
        let mut s = [Poly::default(); RANK];
        for i in 0..RANK {
            let mut prd = [0u8; 64 * ETA1 as usize];
            prf::prf_eta1(&sigma, n, &mut prd);
            sampler::sample_poly_cbd_eta1(&prd, &mut s[i]);
            n += 1;
        }
        (s, n)
    };

    let e = {
        assert_eq!(n, RANK as u8);
        let mut n = n;
        let mut e = [Poly::default(); RANK];
        for i in 0..RANK {
            let mut prd = [0u8; 64 * ETA1 as usize];
            prf::prf_eta1(&sigma, n, &mut prd);
            sampler::sample_poly_cbd_eta1(&prd, &mut e[i]);
            n += 1;
        }
        e
    };

    let sh = s.map(|s| NTT::from_poly(&s));
    let eh = e.map(|e| NTT::from_poly(&e));

    let th = {
        let mut th = eh;
        for i in 0..RANK {
            for j in 0..RANK {
                th[i] = th[i].add(&ah[i][j].mul(&sh[j]));
            }
        }
        th
    };

    let mut pke_ek = [0u8; 384 * RANK + 32];
    for i in 0..RANK {
        byte_encode_12(th[i].into(), &mut pke_ek[i * 32 * 12..(i + 1) * 32 * 12])
    }

    pke_ek[384 * RANK..].copy_from_slice(&rho);

    let pk = EncryptionKey::new(pke_ek, d, rho, sigma);
    let sk = DecryptionKey::new([0u8; 384 * RANK]);

    (pk, sk)
}

#[cfg(test)]
mod pke_keygen_tests {
    use crate::pke::key_gen;
    use hex;

    #[test]
    fn test_key_gen_00() {
        let d = hex::decode("A2B4BCA315A6EA4600B4A316E09A2578AA1E8BCE919C8DF3A96C71C843F5B38B")
            .unwrap();
        let exp_pk: [u8; 1184] = hex::decode("5219C4CC17C35A828F3E21B2AB7496805C99EE041FCA0158A3314F07D053F364C887A6825958A625965D4885C2CB355E83A3C1BBB15446F891D2D24F145632CF06A5EE1A278CD3064A79AD53193853E4CEA654448A4297CEA3C9E87561629680F588953B858074292ED31C20DDD983E805D07BB9CFADD823C7900B604286C0184738CA04E0DA8289540E329605EFAA5960AAC0FD0760006C1F1993426CC7BEA22BCBB3CC02E099B828E82F94045DFACB1D9FB315582B20D1B41476FC43AC4680647259FE9B51371223446C82E0BBAEA132913E2B96EA11950C450F25854EE4FA4921193C8F1C66D61B8265C7072B046F0C532141D51D9919C80733C1BD3C5A6D77CCB3A1938C95C1E4E866D1D65C78297B3B32CA3C4143E6A215C609A36A1B13BAA17981D42B7FF4C715AC806DC491560032A5A2BB30E476A266C6E4A4A065D9698DB08132608136082689B1B648B49063C98324706A43876507FC690893900F8166E1D52ADCC44848D864B8BA0933B32DAA63435F11065915C5D5D879EDCC136FA8515B0260B9536C316120B4904921805521C0232DA126E2A9C5323976ABC73B5AB892E59B01A194B6446C1B73217FBBA855AC887AFA58A8F15A768EF968D775267E050150C7A8237C1024F9421C210D97907B2A144736E3B58E01C48947B1C62655E380256491CEBE400F52493D9033A29D6C9AE80B33E8C38584B30A31A37B15E85F5E82B73157408A5399A957190CBA905F1713C9ACA53AA32923CACB8269436A56BC02932189C7139D8463D0DC540621875E9A7DFEF020E7E83696C7612BC2A7DE7148D7075C31F257766301FA5A06E00582DCE15C6FB3195AF43078D79B110B5DC0789BE3A32132737FEB247DF8D2216F272C3D5BA700C52ED7E3A2795CCFE3072CD1D1B533939AC58A065A8A9FE85441ED291D43869E25307737A5155A095C5056A204326F944A9FC8F7035C931A61033CC2DB6ECEC08AAE0045A6542080C1A7BBD699902A2ECBE3A1F9AA95FC6222C6C6AB7BF96EDB3450E029B0CE104DBBFA0A49B8044EE1BB63B33BCFAA8A6A450194CC577D490A549B6C42D6816F444AAE8B8A4F62AFFD17664E957E2BA245A864BAB8D28E82CAB9FAC3BCD707AAC19A5EE58A3925DC7059BA1B9E7A798EC987E1924342C54E5D935A6699B6D9AA78E4738B0CEC6C57D8228C86881A14A3B57065BBE5653BD92B5BD5A9888B1B1E9B017ECA1A788CBC3A283A9F7B00D3F55B138CA26C33CD2CA3BA632A0735596162AA6C9D10968F53305D35CEC4395CA0489FF631A3EF661264A22ACB535DCC1313CD6917BFE3B5B8FC3B8016CA0DFB151623C92F95701DCC4140459B52EB796FDA60FB429651052D2C16B550FA035CC1374C87A439077713769C728B766BC75A609B70BBC14AF84A3C70519C3211ACAD58BF7C14C15F1AA86FCC1DF55580A2F9BBBC31B6B0EAAB379481CE9966F7FA6487C611BA5B3E8F8307FA35CD5248C8AB351B63ABC4BA005871A97751F01E5143302C757A65E411AF7B26F22076C7A1CF7E2B0055E80D7116CA2B3056BF8754BCFA9095D0CE99715CC4512F10125C5A500DABB7C11F5B0408377900621BE851B7A3602576650B84191749F30AC635A9E2212400769DE8E1915F26BA198AF8E53DACB598711738DA8C583A388E027A59").unwrap().try_into().unwrap();
        let d: [u8; 32] = d.try_into().unwrap();
        let (pk, _) = key_gen(d);
        assert_eq!(pk.key, exp_pk.as_slice());
    }

    #[test]
    fn test_key_gen_01() {
        let d = hex::decode("6dbbc4375136df3b07f7c70e639e223e177e7fd53b161b3f4d57791794f12624")
            .unwrap();
        let exp_pk: [u8; 1184] = hex::decode("01f60af1dc8e6360ae78b59d4a5042eb9145a269046d6236b8304f305c2d9dcb189fe5a62df89b2f5a7bce3bbc753c1e78f730a99869f809aba856b676b707b26601d1d909bab32451494eb7d0a2153a6350b79789a9b115f83ea12037256562f06a1d5aba378da77039d3bdecaca8e6a22a49050a76300a0267cdb38b7ac77903c50ca53b99283cac6b95fba651b11a4d1a692e4072965060587669f253b1bb182e661446168ac60221894660020e9bb5f5b7124a0303e2543ea3ea6ce97a2482b255ca346fb27a847b33b93f3ab2d33064c6e6632d1a23f1144e907b246b479f4a5c928929a1e24150f5241258a5b67766a66f6a33846495907828ebe44ecc5b73124071ba479073910410a16d5d5696b48b194752979795772a91c348f502b37aa650983ebb89bf3c081ff273544129c9137a6e1834c8f2e7ce14c7870c53c05b9b94ecd38e6645911b0912336863ec168831f811881075cf38a59de4b5c738aa6ef03d779b295588cfb62491cc7b3e08b48473354f9ac8061c152a9e205997499b970b69bce66fe42bca2924ccdf0103d0a4c39193c2df25118d72b17aab26b0c60d4cd2c306ca4696c185de05035f4a09cf970aecc8cc93436f83b1aeaf452c41929a2eabc151938f74c93b858546df2264eeeab602e04a85c522f8fb1a5214afd8d4cae57a47b6f381a23126bd9917173128af917f1d483691c450d1151cfe9a1492d473ed862e27da92500c86a20019e9f975e4f54ad319ba2c5630c4014219d7ba235456fe530140193d662445e6a941d1e238567ba8d4d95ab1c7447d690821876d017270cfb169f2d792f03c800720697b410ab41c66f2b24585125655eb10aa1087ffcb7750cb887ad4467377500a6a7d3a82976b415a54469577b4138d919b03f4c9a4d3390bdcb6f1717a5fa4ab25a34f4ba5039bb22c7f3c234ea4427347aa7251464e631904d7cac4784f78b49d5f4a104a301809a779f6466131f9c62bb67147f4cd4973a6aa1c29ae6a8647b6268be089fe048ce990cd638743d285c889a707f581b63af41731f0246b054bc4b47aab01b6842a2709d02e8158ab90f48b69d136082b34cb0673b74aa3f54508ed029fb8f5045ee0639e150ee3b3c85f68a310ec0441980100b42abf2bad10d4a9e0c7b2bc5bbcaf73cbcdc49dc2c949111936779b178974a0392947745a47189bc3fa8a679c80af964a9f9b1b56577274a2a669d2da6704aa496af407fa1aa964cc3dc3140f5f959a7ea974bdb1b83e48a99c0a3e2d75b0669b5c1278962540609166266da18886fc237af30cefd569dbe399e6652e45f06a5dfc9a758a4987088ff8e38a3cf36b9d988f0e070b68d0b88f7bcc41306080d889780c7e238895ccaa4f3577225cca4c8a9330ce613e717798c9670924b271ac402b51538b8b5967ac490dcab5300e6c54d6a3632f3b973e4186ee1a7e2e85649185b26370c387235c4df28a9937a49d4078bf883f4e6346cb3251d9e13f1bda087b285afaa80e262641c5527b0a184b8bc84a62e577314658e2029d850064f7a7b81f253e7cc124a9c5b039dc9b179a80c2f6aee6ea0815172537331a57b505baa76ff5b4c1f0da754b6194f4b39a9b18730d3cdab925d691ed77a8db9927ea233ac2a12744fdc27e5d221b9369adb325d8").unwrap().try_into().unwrap();
        let d: [u8; 32] = d.try_into().unwrap();
        let (pk, _) = key_gen(d);
        assert_eq!(pk.key, exp_pk.as_slice());
    }

    #[test]
    fn test_key_gen_03() {
        let d = hex::decode("6DBB99AE6889AF01DA387D7D99BD4E91BACB11A6051B14AECD4C96F30CD9F9D9")
            .unwrap();
        let d: [u8; 32] = d.try_into().unwrap();
        let exp_pk: [u8; 1184] = hex::decode("BC02284C2B36002A8E002311D6FA3ED17088D6157E76867ED2110B7E50A9F0380893253026D833BE84A75E745CB9291F4E513EB41C68053575FE27893159C353DA6FB2C87757476A269331BB52268F39362DE69968F410C8167FB7195B6DBC3280B9AA5E28CF60071D2DD54323897701591931B6CE4CA0B087EA160A5A067C53665EDA6019E243A86883344041E3639126A2016F4321E3F39507E55F97BA0EF5F447E707BDF62A7609922DBDFC283ADB3CB7B10A083746BDC3B077BC1CEE06CE666B027BCB6E743B974D495D2D0183ECA61369EA52DD4BCDC1A54A8A08B8286A984143559554CAB503CCA2095D5AE54782B2586A778D4D3B6631114D7F543F467076B0CA9157729871DB0BF80065B9824835143B556419AACB9D39BA836E07274D1920682592046C83A37B8795603410B360C1E6B8FAACA706F8C613F97A1A82AB0F28A6239866D834BE02680B542A84ED50B4E98586231657C97A2B3121433914A17C20928E6734B45A8622CCCE69C71D367923447264CC72C26FC4986C26882557B342229AFCF7A8A8B716FEDB2FD2060708F99B6A826CF69551D0A90B4E7B9EC96C0B01F02481804124EA56604585F2B6284C205BDB795906A5C53508BA0627611DA8656600CA36908287A00FB8228B26863570977FF958B315A867488CB142B51377199BBDC2403B3679E34CC476C8929059503CB26838958934AACD0D4B67F69807B70855538C25E246569AD400E4F276CEC425D1229A8485AC5AF650C35A2F1730876FF943A4F6AAF0918EF5B543717298D6AC2D0F08C431D5876D669E2A64A0C6658947FB682B476E2CA04DAA743188200C6F79BF9AD23D78364625CA84D73C70258183AF2CAEB483B2C1F5B24A59B57911149FFC7442B8540561433014582ED6A361210E69575555497498508B86522DF2AB3FCCF64B19A9B8C84B32B8F681F51B97965294CF400CD08643FE9551117940D12338B7E9AB47343036AAC3DA4001428629AE8C362B1977259483B4156E5EC510436158664831BABC05807883B4832D2819305AC8CAA1177115A914C789C864574974F22058F2AAA36A0A31F465B4C52F34C70C28E47D35A1255FD31511A419EA9450A3A2ABB6AB68A544CA3E58CD398129F3A275305AA76AB42643725D3AC97E20690750DA9D340739C8D00A7B710BDE654732AA7C95D3304D7445D5E16C1AE64F99EC98B886AA10B3324F61105718BE0CC25B3A4A3A41C1653C0A255001BD51724BC843A1C5DA4A1350C0A40AC5258B17D725652E6CB4B5606D3CE877FD010ACF776D8A5145ACA06EED684082368C48BBB0284B8F502569E3342AE08619649B700C343E74243DE0A18803DAA6A6D2CBFBDACBACE53A4A5C10F7E7BCD6294B388C982FD794F3377EA9414C4DE70643A82A2F7A7A1B145AF0B1394A4B9399083D0EA8A35AC2BBC5D45D3B06AEAE511DE342AF6674CFA962A1E126BEC7F1252F892CD565596B3099BF60B332D58929C7B1ABB9CCC6D315D36930CAB08527F2776F76992AB977F615CBF8C1773DF0941DA095920806D36AA0F0884256807FF10726C12128FC337B299206050626A18116FE29215DF3817F1BC9EDDBBE2CA26ECCE15A325A9E566345F32A64D868AEBE124F044B0610E9C45A440D855C8F5AAED9A5E09369935779F1B56B9E").unwrap().try_into().unwrap();
        let (pk, _) = key_gen(d);
        assert_eq!(pk.key, exp_pk.as_slice());
    }

    #[test]
    fn test_key_gen_04() {
        let d = hex::decode("7725321C56F925868FF834F5D1EE90A70332AA9283434E122C60A8D474AC6C0F")
            .unwrap();
        let d: [u8; 32] = d.try_into().unwrap();
        let exp_pk: [u8; 1184] = hex::decode("EAD840B81B03BFE75805595DCF0808B83738AF14C758920F80E209D68B9192C5CF0DA397A0BC9A702295B8AC3826DA6F427C9281D937CBE4686F70713B39021CDCB96D71405D4CAFE4068CCDB64643E7540E571DAC0019D3F1235CA8161AE68592223E674C07AC76286C95BB17E78110317840064485D7B16DDB830C807BEC506CDA14C957DAB843781B977A439C612F52A944AB2B6E6A1C221B886097EC4259B0661E550B58376A56F7A62ACCB7A8B94CA02B1797B62497B88B0035623F26086D14122CBC9EB7486B0BC2A8BE25985B2019906977CE971D928347DA5756EBB65835764EEB6B52BA123E61BBC5123645346168597C1194C80ABB26C74EF6500AC6B180C190C28C9041AAACF5371C41373BEDC686BB73B583F46217F31F01B66DCCBC9BD6627DC03250B7E52C690261BE97B42FCCC63EB443952143F5734EF4D336C5311D0B2820A1AA715CBC1A106117BC7159FDF32FDA33C82653727466BB14ECB98FF06E2808CDEC540A2276B34FD633349367576AB50360C88992A675128400DCB07999A2B3978547735BF8A202EEFACE1960AA6649CC08582E92DC928F30BC0E3CA45EF8159F928842CA75A01A013B1A5CD55554274A6D2BC39A4796A129017E7A91A79CE22665940F5F711660ECC5101C230BF927146486AB6546C4E4BB3D8C7D877769B3BA7FE0162397DA4583D30B343862205CAA6D0CBE57000D6F9384D73C6ECB3AB773599B73FAA2F9258EF467BD6266273D1214C103399019751B240C128021F1E698110559B2C56FE32223CDD90D04B766CA425AF66458D8E66BB7029D147CA11E778B5323216C3081D0A6596A7AB5FE886E9C9ACEBA705A3B751F19165916C5855AE29D34D10FBCD68A60C38023243CB1C22D30261292E01D31300569777B099C77F5351FF77C2BA5C09F584CBB6CCB84F11AA264C310FDF253B271CD6450B85F040FF8262F2113141BA3B45E1550D6084BC84A50202B19D23A92CAB5B8C6838F49D99AADD6592B1842EA251F71F3A6707C55C3EC0A3A0314C9A4530F9AC4FBF83B9B73510229B136D5989990B71954BB3889CE54944E01039AC7A9B4EBEC47805A9C51298A7F867BEBDACA71D7AE2012AE2B855CD7C97BA0E14EDE7B8508935D3B0192743B3AE7D3628166AC251A012C59034CD30B8258A159432A62DA317E8A993DC07C8DB73E5B3478D208875D6AC9B64CB36D0B1979AB9D553843BF054CA687B316414E846CB5E305B68C00A8B1C903C7C0CCD03970317C6A1F9A8646B5CABF5112BE01B868402620883E46DAA256228A8092648BA61FF57805E0D03A06C46AD1411CA8E3A95FA73904D3246AF0C4AADA2C582906B54180E9569C86A76B5F88091EB9165F3528B92A8C0549B097FC2A3398A226B224EEEBBE3B3A96066A2C0F884A60FAAAF9E97122C89582395B192172F661B775E09C6662CCB64169BEEC4924E96AB257BA514617161B8F7B316CE0512090DC627D59C4F3A39EAC068554C075E29628383477E5C493150B04D1249D61E6A09E2B323BE503A6512BB119A262B8ADDFB43612654DDF685981063E14DB0DC025520BF20FA3BBCF81D779A98300A4E0A6B6516DA6442968C7BADC129B3D458A1ED8ADA5301E5C3FAF68F13D6DBFA29987FB14563E8C6BEE4EEC9B8AB5F504A8BC1A724E6005").unwrap().try_into().unwrap();
        let (pk, _) = key_gen(d);
        assert_eq!(pk.key, exp_pk.as_slice());
    }
}
